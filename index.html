<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Vice City-ish WebGL2 – Neon Night</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #02030a;
      font-family: Arial, sans-serif;
      color: #eee;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.65);
      padding: 10px 14px;
      border-radius: 8px;
      font-size: 13px;
      box-shadow: 0 0 18px rgba(0,0,0,0.9);
      border: 1px solid rgba(255,102,170,0.6);
      backdrop-filter: blur(4px);
    }
    #ui h1 {
      margin: 0 0 6px 0;
      font-size: 16px;
      color: #ff66aa;
      text-shadow: 0 0 8px rgba(255,102,170,1);
    }
    #ui p {
      margin: 2px 0;
    }
    #ui .hint {
      color: #9fdcff;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<div id="ui">
  <h1>Vice City-ish WebGL2</h1>
  <p><b>Move on foot:</b> WASD</p>
  <p><b>Turn:</b> Q / E</p>
  <p><b>Enter / Exit car:</b> F (near car)</p>
  <p><b>Camera:</b> Locked behind player or car (GTA-style)</p>
  <p class="hint">Neon night, low-poly PS2 dude, collisions, drift.</p>
</div>
<canvas id="glcanvas"></canvas>

<script>
// =========================================================
// Canvas & WebGL2
// =========================================================
const canvas = document.getElementById("glcanvas");
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

/** @type {WebGL2RenderingContext} */
const gl = canvas.getContext("webgl2");
if (!gl) {
  alert("WebGL2 not supported");
  throw new Error("WebGL2 not supported");
}

// =========================================================
// Shaders
// =========================================================
const vsSource = `#version 300 es
precision highp float;

in vec3 aPosition;
in vec3 aNormal;
in vec3 aColor;

uniform mat4 uProjection;
uniform mat4 uView;
uniform mat4 uModel;

out vec3 vColor;
out vec3 vNormal;
out vec3 vWorldPos;

void main(void) {
  vec4 worldPos = uModel * vec4(aPosition, 1.0);
  vWorldPos = worldPos.xyz;
  vNormal = mat3(uModel) * aNormal;
  vColor = aColor;
  gl_Position = uProjection * uView * worldPos;
}
`;

const fsSource = `#version 300 es
precision highp float;

in vec3 vColor;
in vec3 vNormal;
in vec3 vWorldPos;

uniform vec3 uLightDir;
uniform vec3 uAmbientColor;
uniform vec3 uFogColor;
uniform float uFogNear;
uniform float uFogFar;

out vec4 outColor;

void main(void) {
  vec3 n = normalize(vNormal);
  float diff = max(dot(-uLightDir, n), 0.0);
  vec3 lit = vColor * (0.25 + diff * 0.9);
  lit += vec3(0.05, 0.02, 0.08); // tiny neon-ish boost

  float dist = length(vWorldPos.xz);
  float fogFactor = clamp((uFogFar - dist) / (uFogFar - uFogNear), 0.0, 1.0);
  vec3 color = mix(uFogColor, lit, fogFactor);

  outColor = vec4(color, 1.0);
}
`;

// =========================================================
// Shader helpers
// =========================================================
function compileShader(src, type) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    throw new Error("Shader compile failed");
  }
  return shader;
}

function createProgram(vsSrc, fsSrc) {
  const vs = compileShader(vsSrc, gl.VERTEX_SHADER);
  const fs = compileShader(fsSrc, gl.FRAGMENT_SHADER);
  const prog = gl.createProgram();
  gl.attachShader(prog, vs);
  gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(prog));
    throw new Error("Program link failed");
  }
  return prog;
}

const program = createProgram(vsSource, fsSource);
gl.useProgram(program);

// =========================================================
// Locations
// =========================================================
const attribs = {
  position: gl.getAttribLocation(program, "aPosition"),
  normal:   gl.getAttribLocation(program, "aNormal"),
  color:    gl.getAttribLocation(program, "aColor")
};

const uniforms = {
  projection: gl.getUniformLocation(program, "uProjection"),
  view:       gl.getUniformLocation(program, "uView"),
  model:      gl.getUniformLocation(program, "uModel"),
  lightDir:   gl.getUniformLocation(program, "uLightDir"),
  ambient:    gl.getUniformLocation(program, "uAmbientColor"),
  fogColor:   gl.getUniformLocation(program, "uFogColor"),
  fogNear:    gl.getUniformLocation(program, "uFogNear"),
  fogFar:     gl.getUniformLocation(program, "uFogFar")
};

// =========================================================
// Math helpers
// =========================================================
function mat4Identity() {
  return [1,0,0,0,
          0,1,0,0,
          0,0,1,0,
          0,0,0,1];
}

function mat4Multiply(a, b) {
  const out = new Array(16);
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      out[i*4 + j] =
        a[i*4 + 0] * b[0*4 + j] +
        a[i*4 + 1] * b[1*4 + j] +
        a[i*4 + 2] * b[2*4 + j] +
        a[i*4 + 3] * b[3*4 + j];
    }
  }
  return out;
}

function mat4Translate(m, v) {
  const [x,y,z] = v;
  const t = mat4Identity();
  t[12] = x;
  t[13] = y;
  t[14] = z;
  return mat4Multiply(m, t);
}

function mat4Scale(m, v) {
  const [x,y,z] = v;
  const s = mat4Identity();
  s[0] = x;
  s[5] = y;
  s[10] = z;
  return mat4Multiply(m, s);
}

function mat4RotateY(m, rad) {
  const c = Math.cos(rad);
  const s = Math.sin(rad);
  const r = [
    c, 0, -s, 0,
    0, 1,  0, 0,
    s, 0,  c, 0,
    0, 0,  0, 1
  ];
  return mat4Multiply(m, r);
}

function mat4Perspective(fov, aspect, near, far) {
  const f = 1.0 / Math.tan(fov / 2);
  const nf = 1 / (near - far);
  const out = new Array(16);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;

  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;

  out[8] = 0;
  out[9] = 0;
  out[10] = (far + near) * nf;
  out[11] = -1;

  out[12] = 0;
  out[13] = 0;
  out[14] = (2 * far * near) * nf;
  out[15] = 0;
  return out;
}

function vec3Normalize(v) {
  const len = Math.hypot(v[0], v[1], v[2]);
  if (len === 0) return [0,0,0];
  return [v[0]/len, v[1]/len, v[2]/len];
}

function mat4LookAt(eye, center, up) {
  const [ex,ey,ez] = eye;
  const [cx,cy,cz] = center;
  const [ux,uy,uz] = up;

  let zx = ex - cx;
  let zy = ey - cy;
  let zz = ez - cz;
  let zlen = Math.hypot(zx, zy, zz);
  if (zlen === 0) {
    zx = 0; zy = 0; zz = 1; zlen = 1;
  }
  zx /= zlen; zy /= zlen; zz /= zlen;

  let xx = uy * zz - uz * zy;
  let xy = uz * zx - ux * zz;
  let xz = ux * zy - uy * zx;
  let xlen = Math.hypot(xx, xy, xz);
  if (xlen === 0) {
    xx = 1; xy = 0; xz = 0; xlen = 1;
  }
  xx /= xlen; xy /= xlen; xz /= xlen;

  let yx = zy * xz - zz * xy;
  let yy = zz * xx - zx * xz;
  let yz = zx * xy - zy * xx;

  const out = mat4Identity();
  out[0] = xx; out[1] = yx; out[2] = zx; out[3] = 0;
  out[4] = xy; out[5] = yy; out[6] = zy; out[7] = 0;
  out[8] = xz; out[9] = yz; out[10] = zz; out[11] = 0;
  out[12] = -(xx*ex + xy*ey + xz*ez);
  out[13] = -(yx*ex + yy*ey + yz*ez);
  out[14] = -(zx*ex + zy*ey + zz*ez);
  out[15] = 1;
  return out;
}

// =========================================================
// Geometry
// =========================================================
function createCubeGeometry(color) {
  const c = color || [1,1,1];

  const positions = [
    // Front
    -1,-1, 1,
     1,-1, 1,
     1, 1, 1,
    -1, 1, 1,
    // Back
    -1,-1,-1,
    -1, 1,-1,
     1, 1,-1,
     1,-1,-1,
    // Top
    -1, 1,-1,
    -1, 1, 1,
     1, 1, 1,
     1, 1,-1,
    // Bottom
    -1,-1,-1,
     1,-1,-1,
     1,-1, 1,
    -1,-1, 1,
    // Right
     1,-1,-1,
     1, 1,-1,
     1, 1, 1,
     1,-1, 1,
    // Left
    -1,-1,-1,
    -1,-1, 1,
    -1, 1, 1,
    -1, 1,-1
  ];

  const normals = [
    // Front
    0,0,1, 0,0,1, 0,0,1, 0,0,1,
    // Back
    0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1,
    // Top
    0,1,0, 0,1,0, 0,1,0, 0,1,0,
    // Bottom
    0,-1,0, 0,-1,0, 0,-1,0, 0,-1,0,
    // Right
    1,0,0, 1,0,0, 1,0,0, 1,0,0,
    // Left
    -1,0,0, -1,0,0, -1,0,0, -1,0,0
  ];

  const colors = [];
  for (let i = 0; i < 24; i++) {
    colors.push(c[0], c[1], c[2]);
  }

  const indices = [
    0,1,2, 0,2,3,
    4,5,6, 4,6,7,
    8,9,10, 8,10,11,
    12,13,14, 12,14,15,
    16,17,18, 16,18,19,
    20,21,22, 20,22,23
  ];

  return { positions, normals, colors, indices };
}

// =========================================================
// Mesh with VAO
// =========================================================
function createMesh(geom) {
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);

  const posBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geom.positions), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(attribs.position);
  gl.vertexAttribPointer(attribs.position, 3, gl.FLOAT, false, 0, 0);

  const norBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, norBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geom.normals), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(attribs.normal);
  gl.vertexAttribPointer(attribs.normal, 3, gl.FLOAT, false, 0, 0);

  const colBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, colBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geom.colors), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(attribs.color);
  gl.vertexAttribPointer(attribs.color, 3, gl.FLOAT, false, 0, 0);

  const idxBuf = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(geom.indices), gl.STATIC_DRAW);

  gl.bindVertexArray(null);

  return {
    vao,
    count: geom.indices.length
  };
}

// =========================================================
// Scene setup – Vice City-ish
// =========================================================
const groundColor   = [0.02, 0.05, 0.10];
const roadColor     = [0.03, 0.03, 0.05];
const sidewalkColor = [0.10, 0.10, 0.16];
const buildingColor1 = [0.9, 0.4, 0.8];
const buildingColor2 = [0.3, 0.7, 1.0];
const buildingColor3 = [0.9, 0.9, 0.4];
const palmTrunkColor = [0.35, 0.20, 0.10];
const palmLeafColor  = [0.1, 0.8, 0.4];
const carColor       = [1.0, 0.2, 0.4];
const playerBodyColor= [0.9, 0.8, 0.7];
const playerShirtColor=[0.1, 0.7, 0.9];
const playerPantsColor=[0.05, 0.05, 0.15];

const cubeGround   = createMesh(createCubeGeometry(groundColor));
const cubeRoad     = createMesh(createCubeGeometry(roadColor));
const cubeSidewalk = createMesh(createCubeGeometry(sidewalkColor));
const cubeBuilding1= createMesh(createCubeGeometry(buildingColor1));
const cubeBuilding2= createMesh(createCubeGeometry(buildingColor2));
const cubeBuilding3= createMesh(createCubeGeometry(buildingColor3));
const cubePalmTrunk= createMesh(createCubeGeometry(palmTrunkColor));
const cubePalmLeaf = createMesh(createCubeGeometry(palmLeafColor));
const cubeCar      = createMesh(createCubeGeometry(carColor));
const cubePlayerBody = createMesh(createCubeGeometry(playerBodyColor));
const cubePlayerShirt= createMesh(createCubeGeometry(playerShirtColor));
const cubePlayerPants= createMesh(createCubeGeometry(playerPantsColor));

// City layout
const buildings = [];
const roads = [];
const sidewalks = [];
const palms = [];

const blockSize = 30;
const halfBlocks = 4;

// Generate grid: roads + blocks + buildings + palms
for (let bx = -halfBlocks; bx <= halfBlocks; bx++) {
  for (let bz = -halfBlocks; bz <= halfBlocks; bz++) {
    const worldX = bx * blockSize;
    const worldZ = bz * blockSize;

    // Roads along X and Z
    if (bx % 2 === 0 || bz % 2 === 0) {
      roads.push({ x: worldX, z: worldZ });
      // Sidewalks around roads
      sidewalks.push({ x: worldX + 10, z: worldZ });
      sidewalks.push({ x: worldX - 10, z: worldZ });
      sidewalks.push({ x: worldX, z: worldZ + 10 });
      sidewalks.push({ x: worldX, z: worldZ - 10 });
    } else {
      // Building block
      const numBuildings = 3 + Math.floor(Math.random() * 4);
      for (let i = 0; i < numBuildings; i++) {
        const offX = (Math.random() - 0.5) * 16;
        const offZ = (Math.random() - 0.5) * 16;
        const h = 6 + Math.random() * 30;
        const colorPick = Math.random();
        let mesh;
        if (colorPick < 0.33) mesh = cubeBuilding1;
        else if (colorPick < 0.66) mesh = cubeBuilding2;
        else mesh = cubeBuilding3;
        buildings.push({
          mesh,
          x: worldX + offX,
          z: worldZ + offZ,
          h,
          w: 6 + Math.random() * 4,
          d: 6 + Math.random() * 4
        });
      }

      // Palms around edges of block
      const palmCount = 4 + Math.floor(Math.random() * 4);
      for (let i = 0; i < palmCount; i++) {
        const edge = Math.random();
        let px = worldX + (edge < 0.5 ? -blockSize/2 + 3 : blockSize/2 - 3);
        let pz = worldZ + (Math.random() - 0.5) * (blockSize - 8);
        if (Math.random() < 0.5) {
          px = worldX + (Math.random() - 0.5) * (blockSize - 8);
          pz = worldZ + (edge < 0.5 ? -blockSize/2 + 3 : blockSize/2 - 3);
        }
        palms.push({
          x: px,
          z: pz,
          h: 8 + Math.random() * 4
        });
      }
    }
  }
}

// Player & car
const player = {
  x: 0,
  y: 1,
  z: 0,
  rotY: 0,
  speed: 0,
  maxSpeed: 0.18,
  accel: 0.012,
  friction: 0.86,
  radiusX: 0.6,
  radiusZ: 0.6,
  height: 1.8
};

const car = {
  x: 12,
  y: 1,
  z: -12,
  rotY: Math.PI * 0.25,
  speed: 0,
  maxSpeed: 0.55,
  accel: 0.03,
  friction: 0.93,
  radiusX: 1.2,
  radiusZ: 2.0,
  height: 1.0
};

let inCar = false;

// =========================================================
// Input
// =========================================================
const keys = {};
window.addEventListener("keydown", (e) => {
  keys[e.key.toLowerCase()] = true;
});
window.addEventListener("keyup", (e) => {
  keys[e.key.toLowerCase()] = false;
});

// =========================================================
// Collision helpers (AABB vs buildings)
// =========================================================
function testAABBvsAABB(ax, ay, az, aw, ah, ad, bx, by, bz, bw, bh, bd) {
  return (
    Math.abs(ax - bx) * 2 < (aw + bw) &&
    Math.abs(ay - by) * 2 < (ah + bh) &&
    Math.abs(az - bz) * 2 < (ad + bd)
  );
}

function resolveCollisions(ent) {
  // Simple: if colliding with any building, push back along movement axis
  for (let i = 0; i < buildings.length; i++) {
    const b = buildings[i];
    const ex = ent.x;
    const ez = ent.z;
    const ey = ent.y + ent.height * 0.5;
    const bw = b.w;
    const bd = b.d;
    const bh = b.h;

    if (testAABBvsAABB(
      ex, ey, ez, ent.radiusX*2, ent.height, ent.radiusZ*2,
      b.x, bh*0.5, b.z, bw, bh, bd
    )) {
      // Push out on X/Z
      const dx = ex - b.x;
      const dz = ez - b.z;
      if (Math.abs(dx) > Math.abs(dz)) {
        ent.x = b.x + Math.sign(dx) * (bw/2 + ent.radiusX);
        ent.speed *= 0.3;
      } else {
        ent.z = b.z + Math.sign(dz) * (bd/2 + ent.radiusZ);
        ent.speed *= 0.3;
      }
    }
  }
}

// =========================================================
// Movement & camera
// =========================================================
function getControlledEntity() {
  return inCar ? car : player;
}

function updateMovement(dt) {
  const ent = getControlledEntity();

  // Turn Q/E
  const turnSpeed = inCar ? 2.2 : 1.8;
  if (keys["q"]) ent.rotY += turnSpeed * dt;
  if (keys["e"]) ent.rotY -= turnSpeed * dt;

  // Forward/back W/S
  let forward = 0;
  if (keys["w"]) forward += 1;
  if (keys["s"]) forward -= 1;

  if (forward !== 0) {
    ent.speed += forward * ent.accel;
    if (ent.speed > ent.maxSpeed) ent.speed = ent.maxSpeed;
    if (ent.speed < -ent.maxSpeed * 0.4) ent.speed = -ent.maxSpeed * 0.4;
  } else {
    ent.speed *= ent.friction;
  }

  // Drift-ish: car has lower friction sideways (fake)
  const dx = Math.sin(ent.rotY) * ent.speed;
  const dz = Math.cos(ent.rotY) * ent.speed;

  ent.x += dx;
  ent.z += dz;
  ent.y = 1;

  resolveCollisions(ent);

  // Enter / exit car with F
  if (keys["f"]) {
    if (!updateMovement._fPressed) {
      updateMovement._fPressed = true;
      if (!inCar) {
        const dist = Math.hypot(player.x - car.x, player.z - car.z);
        if (dist < 4) {
          inCar = true;
          player.x = car.x;
          player.z = car.z;
          player.rotY = car.rotY;
        }
      } else {
        inCar = false;
        player.x = car.x - Math.sin(car.rotY) * 3;
        player.z = car.z - Math.cos(car.rotY) * 3;
        player.rotY = car.rotY;
      }
    }
  } else {
    updateMovement._fPressed = false;
  }
}

// Camera smoothing
let camPos = { x: -10, y: 5, z: -10 };
let camTarget = { x: 0, y: 2, z: 0 };

function computeCamera(dt) {
  const ent = getControlledEntity();

  const camDistance = inCar ? 15.0 : 9.0;
  const camHeight   = inCar ? 5.0  : 3.2;

  const targetX = ent.x;
  const targetY = ent.y + 1.6;
  const targetZ = ent.z;

  const behindX = targetX - Math.sin(ent.rotY) * camDistance;
  const behindZ = targetZ - Math.cos(ent.rotY) * camDistance;
  const behindY = targetY + camHeight;

  const lerpFactor = 1.0 - Math.pow(0.001, dt * 60.0); // smooth but responsive
  camPos.x += (behindX - camPos.x) * lerpFactor;
  camPos.y += (behindY - camPos.y) * lerpFactor;
  camPos.z += (behindZ - camPos.z) * lerpFactor;

  camTarget.x += (targetX - camTarget.x) * lerpFactor;
  camTarget.y += (targetY - camTarget.y) * lerpFactor;
  camTarget.z += (targetZ - camTarget.z) * lerpFactor;

  return mat4LookAt(
    [camPos.x, camPos.y, camPos.z],
    [camTarget.x, camTarget.y, camTarget.z],
    [0,1,0]
  );
}

// =========================================================
// Draw helpers
// =========================================================
function drawMesh(mesh, modelMatrix) {
  gl.uniformMatrix4fv(uniforms.model, false, new Float32Array(modelMatrix));
  gl.bindVertexArray(mesh.vao);
  gl.drawElements(gl.TRIANGLES, mesh.count, gl.UNSIGNED_SHORT, 0);
}

// Low-poly PS2 dude: body, head, legs, arms
function drawPlayer() {
  // Torso
  let m = mat4Identity();
  m = mat4Translate(m, [player.x, player.y + 1.0, player.z]);
  m = mat4RotateY(m, player.rotY);
  let part = mat4Scale(m, [0.6, 0.8, 0.3]);
  drawMesh(cubePlayerShirt, part);

  // Head
  let head = mat4Translate(m, [0, 0.9, 0]);
  head = mat4Scale(head, [0.4, 0.4, 0.4]);
  drawMesh(cubePlayerBody, head);

  // Legs
  let legs = mat4Translate(m, [0, -0.7, 0]);
  legs = mat4Scale(legs, [0.4, 0.8, 0.3]);
  drawMesh(cubePlayerPants, legs);

  // Arms (simple blocks)
  let armL = mat4Translate(m, [-0.6, 0.3, 0]);
  armL = mat4Scale(armL, [0.2, 0.7, 0.25]);
  drawMesh(cubePlayerBody, armL);

  let armR = mat4Translate(m, [0.6, 0.3, 0]);
  armR = mat4Scale(armR, [0.2, 0.7, 0.25]);
  drawMesh(cubePlayerBody, armR);
}

// Car
function drawCar() {
  let m = mat4Identity();
  m = mat4Translate(m, [car.x, car.y, car.z]);
  m = mat4RotateY(m, car.rotY);
  m = mat4Scale(m, [1.6, 0.7, 3.2]);
  drawMesh(cubeCar, m);
}

// Palms
function drawPalm(p) {
  // Trunk
  let m = mat4Identity();
  m = mat4Translate(m, [p.x, p.h * 0.5, p.z]);
  m = mat4Scale(m, [0.4, p.h * 0.5, 0.4]);
  drawMesh(cubePalmTrunk, m);

  // Leaves (crossed)
  let topY = p.h + 0.5;
  let leafLen = 2.5;
  for (let i = 0; i < 4; i++) {
    let angle = (Math.PI / 2) * i;
    let lm = mat4Identity();
    lm = mat4Translate(lm, [p.x, topY, p.z]);
    lm = mat4RotateY(lm, angle);
    lm = mat4Translate(lm, [0, 0, leafLen * 0.5]);
    lm = mat4Scale(lm, [0.3, 0.2, leafLen]);
    drawMesh(cubePalmLeaf, lm);
  }
}

// =========================================================
// Main loop
// =========================================================
let lastTime = performance.now();

function render(now) {
  requestAnimationFrame(render);
  const dt = Math.min((now - lastTime) / 1000, 0.05);
  lastTime = now;

  updateMovement(dt);

  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.enable(gl.DEPTH_TEST);
  gl.clearColor(0.01, 0.01, 0.03, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  const aspect = canvas.width / canvas.height;
  const projection = mat4Perspective(Math.PI / 3, aspect, 0.1, 400.0);
  const view = computeCamera(dt);

  gl.useProgram(program);
  gl.uniformMatrix4fv(uniforms.projection, false, new Float32Array(projection));
  gl.uniformMatrix4fv(uniforms.view, false, new Float32Array(view));

  gl.uniform3fv(uniforms.lightDir, new Float32Array(vec3Normalize([0.4, 1.0, 0.3])));
  gl.uniform3fv(uniforms.ambient,  new Float32Array([0.08, 0.08, 0.12]));
  gl.uniform3fv(uniforms.fogColor, new Float32Array([0.01, 0.01, 0.05]));
  gl.uniform1f(uniforms.fogNear, 25.0);
  gl.uniform1f(uniforms.fogFar,  220.0);

  // Ground
  let model = mat4Identity();
  model = mat4Translate(model, [0, -1, 0]);
  model = mat4Scale(model, [blockSize * (halfBlocks+2), 1, blockSize * (halfBlocks+2)]);
  drawMesh(cubeGround, model);

  // Roads
  for (let i = 0; i < roads.length; i++) {
    const r = roads[i];
    let m = mat4Identity();
    m = mat4Translate(m, [r.x, -0.49, r.z]);
    m = mat4Scale(m, [blockSize * 0.5, 0.1, blockSize * 0.5]);
    drawMesh(cubeRoad, m);
  }

  // Sidewalks
  for (let i = 0; i < sidewalks.length; i++) {
    const s = sidewalks[i];
    let m = mat4Identity();
    m = mat4Translate(m, [s.x, -0.3, s.z]);
    m = mat4Scale(m, [4, 0.2, 4]);
    drawMesh(cubeSidewalk, m);
  }

  // Buildings
  for (let i = 0; i < buildings.length; i++) {
    const b = buildings[i];
    let m = mat4Identity();
    m = mat4Translate(m, [b.x, b.h * 0.5, b.z]);
    m = mat4Scale(m, [b.w, b.h * 0.5, b.d]);
    drawMesh(b.mesh, m);
  }

  // Palms
  for (let i = 0; i < palms.length; i++) {
    drawPalm(palms[i]);
  }

  // Car
  drawCar();

  // Player (only when not in car)
  if (!inCar) {
    drawPlayer();
  }
}

render(performance.now());
</script>
</body>
</html>
