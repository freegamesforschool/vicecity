<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Vice City-ish WebGL2 Demo</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #05070b;
      font-family: Arial, sans-serif;
      color: #eee;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.55);
      padding: 10px 14px;
      border-radius: 8px;
      font-size: 13px;
      box-shadow: 0 0 12px rgba(0,0,0,0.7);
      border: 1px solid rgba(255,102,170,0.4);
    }
    #ui h1 {
      margin: 0 0 6px 0;
      font-size: 16px;
      color: #ff66aa;
      text-shadow: 0 0 6px rgba(255,102,170,0.8);
    }
    #ui p {
      margin: 2px 0;
    }
    #ui .hint {
      color: #9fdcff;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<div id="ui">
  <h1>Vice City-ish WebGL2</h1>
  <p><b>Move on foot:</b> WASD</p>
  <p><b>Turn:</b> Q / E</p>
  <p><b>Enter / Exit car:</b> F (near car)</p>
  <p><b>Camera:</b> Locked behind player or car</p>
  <p class="hint">Very rough prototype, but fully 3D + chase cam.</p>
</div>
<canvas id="glcanvas"></canvas>

<script>
// =========================================================
// Canvas & WebGL2 setup
// =========================================================
const canvas = document.getElementById("glcanvas");
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// Request WebGL2 explicitly
/** @type {WebGL2RenderingContext} */
const gl = canvas.getContext("webgl2");
if (!gl) {
  alert("WebGL2 not supported in this browser.");
  throw new Error("WebGL2 not supported");
}

// =========================================================
// Shaders
// =========================================================
const vsSource = `#version 300 es
precision highp float;

in vec3 aPosition;
in vec3 aNormal;
in vec3 aColor;

uniform mat4 uProjection;
uniform mat4 uView;
uniform mat4 uModel;

out vec3 vColor;
out vec3 vNormal;
out vec3 vWorldPos;

void main(void) {
  vec4 worldPos = uModel * vec4(aPosition, 1.0);
  vWorldPos = worldPos.xyz;
  vNormal = mat3(uModel) * aNormal;
  vColor = aColor;
  gl_Position = uProjection * uView * worldPos;
}
`;

const fsSource = `#version 300 es
precision highp float;

in vec3 vColor;
in vec3 vNormal;
in vec3 vWorldPos;

uniform vec3 uLightDir;
uniform vec3 uAmbientColor;
uniform vec3 uFogColor;
uniform float uFogNear;
uniform float uFogFar;

out vec4 outColor;

void main(void) {
  vec3 n = normalize(vNormal);
  float diff = max(dot(-uLightDir, n), 0.0);
  vec3 base = vColor * (0.25 + diff * 0.75);

  float dist = length(vWorldPos);
  float fogFactor = clamp((uFogFar - dist) / (uFogFar - uFogNear), 0.0, 1.0);
  vec3 color = mix(uFogColor, base, fogFactor);

  outColor = vec4(color, 1.0);
}
`;

// =========================================================
function compileShader(src, type) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    throw new Error("Shader compile failed");
  }
  return shader;
}

function createProgram(vsSrc, fsSrc) {
  const vs = compileShader(vsSrc, gl.VERTEX_SHADER);
  const fs = compileShader(fsSrc, gl.FRAGMENT_SHADER);
  const prog = gl.createProgram();
  gl.attachShader(prog, vs);
  gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(prog));
    throw new Error("Program link failed");
  }
  return prog;
}

const program = createProgram(vsSource, fsSource);
gl.useProgram(program);

// =========================================================
// Attribute / uniform locations
// =========================================================
const attribs = {
  position: gl.getAttribLocation(program, "aPosition"),
  normal:   gl.getAttribLocation(program, "aNormal"),
  color:    gl.getAttribLocation(program, "aColor")
};

const uniforms = {
  projection: gl.getUniformLocation(program, "uProjection"),
  view:       gl.getUniformLocation(program, "uView"),
  model:      gl.getUniformLocation(program, "uModel"),
  lightDir:   gl.getUniformLocation(program, "uLightDir"),
  ambient:    gl.getUniformLocation(program, "uAmbientColor"),
  fogColor:   gl.getUniformLocation(program, "uFogColor"),
  fogNear:    gl.getUniformLocation(program, "uFogNear"),
  fogFar:     gl.getUniformLocation(program, "uFogFar")
};

// =========================================================
// Minimal math helpers
// =========================================================
function mat4Identity() {
  return [1,0,0,0,
          0,1,0,0,
          0,0,1,0,
          0,0,0,1];
}

function mat4Multiply(a, b) {
  const out = new Array(16);
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      out[i*4 + j] =
        a[i*4 + 0] * b[0*4 + j] +
        a[i*4 + 1] * b[1*4 + j] +
        a[i*4 + 2] * b[2*4 + j] +
        a[i*4 + 3] * b[3*4 + j];
    }
  }
  return out;
}

function mat4Translate(m, v) {
  const [x,y,z] = v;
  const t = mat4Identity();
  t[12] = x;
  t[13] = y;
  t[14] = z;
  return mat4Multiply(m, t);
}

function mat4Scale(m, v) {
  const [x,y,z] = v;
  const s = mat4Identity();
  s[0] = x;
  s[5] = y;
  s[10] = z;
  return mat4Multiply(m, s);
}

function mat4RotateY(m, rad) {
  const c = Math.cos(rad);
  const s = Math.sin(rad);
  const r = [
    c, 0, -s, 0,
    0, 1,  0, 0,
    s, 0,  c, 0,
    0, 0,  0, 1
  ];
  return mat4Multiply(m, r);
}

function mat4Perspective(fov, aspect, near, far) {
  const f = 1.0 / Math.tan(fov / 2);
  const nf = 1 / (near - far);
  const out = new Array(16);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;

  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;

  out[8] = 0;
  out[9] = 0;
  out[10] = (far + near) * nf;
  out[11] = -1;

  out[12] = 0;
  out[13] = 0;
  out[14] = (2 * far * near) * nf;
  out[15] = 0;
  return out;
}

function vec3Normalize(v) {
  const len = Math.hypot(v[0], v[1], v[2]);
  if (len === 0) return [0,0,0];
  return [v[0]/len, v[1]/len, v[2]/len];
}

function mat4LookAt(eye, center, up) {
  const [ex,ey,ez] = eye;
  const [cx,cy,cz] = center;
  const [ux,uy,uz] = up;

  let zx = ex - cx;
  let zy = ey - cy;
  let zz = ez - cz;
  let zlen = Math.hypot(zx, zy, zz);
  if (zlen === 0) {
    zx = 0; zy = 0; zz = 1; zlen = 1;
  }
  zx /= zlen; zy /= zlen; zz /= zlen;

  let xx = uy * zz - uz * zy;
  let xy = uz * zx - ux * zz;
  let xz = ux * zy - uy * zx;
  let xlen = Math.hypot(xx, xy, xz);
  if (xlen === 0) {
    xx = 1; xy = 0; xz = 0; xlen = 1;
  }
  xx /= xlen; xy /= xlen; xz /= xlen;

  let yx = zy * xz - zz * xy;
  let yy = zz * xx - zx * xz;
  let yz = zx * xy - zy * xx;

  const out = mat4Identity();
  out[0] = xx; out[1] = yx; out[2] = zx; out[3] = 0;
  out[4] = xy; out[5] = yy; out[6] = zy; out[7] = 0;
  out[8] = xz; out[9] = yz; out[10] = zz; out[11] = 0;
  out[12] = -(xx*ex + xy*ey + xz*ez);
  out[13] = -(yx*ex + yy*ey + yz*ez);
  out[14] = -(zx*ex + zy*ey + zz*ez);
  out[15] = 1;
  return out;
}

// =========================================================
// Geometry: cube
// =========================================================
function createCubeGeometry(color) {
  const c = color || [1,1,1];

  const positions = [
    // Front
    -1,-1, 1,
     1,-1, 1,
     1, 1, 1,
    -1, 1, 1,
    // Back
    -1,-1,-1,
    -1, 1,-1,
     1, 1,-1,
     1,-1,-1,
    // Top
    -1, 1,-1,
    -1, 1, 1,
     1, 1, 1,
     1, 1,-1,
    // Bottom
    -1,-1,-1,
     1,-1,-1,
     1,-1, 1,
    -1,-1, 1,
    // Right
     1,-1,-1,
     1, 1,-1,
     1, 1, 1,
     1,-1, 1,
    // Left
    -1,-1,-1,
    -1,-1, 1,
    -1, 1, 1,
    -1, 1,-1
  ];

  const normals = [
    // Front
    0,0,1, 0,0,1, 0,0,1, 0,0,1,
    // Back
    0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1,
    // Top
    0,1,0, 0,1,0, 0,1,0, 0,1,0,
    // Bottom
    0,-1,0, 0,-1,0, 0,-1,0, 0,-1,0,
    // Right
    1,0,0, 1,0,0, 1,0,0, 1,0,0,
    // Left
    -1,0,0, -1,0,0, -1,0,0, -1,0,0
  ];

  const colors = [];
  for (let i = 0; i < 24; i++) {
    colors.push(c[0], c[1], c[2]);
  }

  const indices = [
    0,1,2, 0,2,3,
    4,5,6, 4,6,7,
    8,9,10, 8,10,11,
    12,13,14, 12,14,15,
    16,17,18, 16,18,19,
    20,21,22, 20,22,23
  ];

  return { positions, normals, colors, indices };
}

// =========================================================
// Mesh creation using WebGL2 VAOs
// =========================================================
function createMesh(geom) {
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);

  const posBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geom.positions), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(attribs.position);
  gl.vertexAttribPointer(attribs.position, 3, gl.FLOAT, false, 0, 0);

  const norBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, norBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geom.normals), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(attribs.normal);
  gl.vertexAttribPointer(attribs.normal, 3, gl.FLOAT, false, 0, 0);

  const colBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, colBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geom.colors), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(attribs.color);
  gl.vertexAttribPointer(attribs.color, 3, gl.FLOAT, false, 0, 0);

  const idxBuf = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(geom.indices), gl.STATIC_DRAW);

  gl.bindVertexArray(null);

  return {
    vao,
    count: geom.indices.length
  };
}

// =========================================================
// Scene setup
// =========================================================
const groundColor   = [0.05, 0.12, 0.18];
const buildingColor = [0.18, 0.45, 0.8];
const carColor      = [0.95, 0.15, 0.25];
const playerColor   = [0.95, 0.95, 0.25];

const cubeMeshGround   = createMesh(createCubeGeometry(groundColor));
const cubeMeshBuilding = createMesh(createCubeGeometry(buildingColor));
const cubeMeshCar      = createMesh(createCubeGeometry(carColor));
const cubeMeshPlayer   = createMesh(createCubeGeometry(playerColor));

// Simple city grid
const buildings = [];
for (let x = -6; x <= 6; x++) {
  for (let z = -6; z <= 6; z++) {
    if (Math.abs(x) < 2 && Math.abs(z) < 2) continue;
    if (Math.random() < 0.45) {
      buildings.push({
        x: x * 9,
        z: z * 9,
        h: 4 + Math.random() * 22
      });
    }
  }
}

// Player & car
const player = {
  x: 0,
  y: 1,
  z: 0,
  rotY: 0,
  speed: 0,
  maxSpeed: 0.16,
  accel: 0.012,
  friction: 0.88
};

const car = {
  x: 12,
  y: 1,
  z: -12,
  rotY: Math.PI * 0.25,
  speed: 0,
  maxSpeed: 0.45,
  accel: 0.025,
  friction: 0.93
};

let inCar = false;

// =========================================================
// Input
// =========================================================
const keys = {};
window.addEventListener("keydown", (e) => {
  keys[e.key.toLowerCase()] = true;
});
window.addEventListener("keyup", (e) => {
  keys[e.key.toLowerCase()] = false;
});

// =========================================================
// Movement & camera
// =========================================================
function getControlledEntity() {
  return inCar ? car : player;
}

function updateMovement() {
  const ent = getControlledEntity();

  // Turn Q/E
  if (keys["q"]) ent.rotY += 0.055;
  if (keys["e"]) ent.rotY -= 0.055;

  // Forward/back W/S
  let forward = 0;
  if (keys["w"]) forward += 1;
  if (keys["s"]) forward -= 1;

  if (forward !== 0) {
    ent.speed += forward * ent.accel;
    if (ent.speed > ent.maxSpeed) ent.speed = ent.maxSpeed;
    if (ent.speed < -ent.maxSpeed * 0.5) ent.speed = -ent.maxSpeed * 0.5;
  } else {
    ent.speed *= ent.friction;
  }

  const dx = Math.sin(ent.rotY) * ent.speed;
  const dz = Math.cos(ent.rotY) * ent.speed;

  ent.x += dx;
  ent.z += dz;
  ent.y = 1;

  // Enter / exit car with F
  if (keys["f"]) {
    if (!updateMovement._fPressed) {
      updateMovement._fPressed = true;
      if (!inCar) {
        const dist = Math.hypot(player.x - car.x, player.z - car.z);
        if (dist < 4) {
          inCar = true;
          player.x = car.x;
          player.z = car.z;
          player.rotY = car.rotY;
        }
      } else {
        inCar = false;
        player.x = car.x - Math.sin(car.rotY) * 3;
        player.z = car.z - Math.cos(car.rotY) * 3;
        player.rotY = car.rotY;
      }
    }
  } else {
    updateMovement._fPressed = false;
  }
}

function computeCamera() {
  const ent = getControlledEntity();

  const camDistance = inCar ? 13.0 : 8.5;
  const camHeight   = inCar ? 4.2  : 3.0;

  const behindX = ent.x - Math.sin(ent.rotY) * camDistance;
  const behindZ = ent.z - Math.cos(ent.rotY) * camDistance;
  const eye     = [behindX, ent.y + camHeight, behindZ];
  const center  = [ent.x, ent.y + 1.6, ent.z];
  const up      = [0,1,0];

  return mat4LookAt(eye, center, up);
}

// =========================================================
// Draw helpers
// =========================================================
function drawMesh(mesh, modelMatrix) {
  gl.uniformMatrix4fv(uniforms.model, false, new Float32Array(modelMatrix));
  gl.bindVertexArray(mesh.vao);
  gl.drawElements(gl.TRIANGLES, mesh.count, gl.UNSIGNED_SHORT, 0);
}

// =========================================================
// Main loop
// =========================================================
function render() {
  requestAnimationFrame(render);

  updateMovement();

  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.enable(gl.DEPTH_TEST);
  gl.clearColor(0.02, 0.03, 0.06, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  const aspect = canvas.width / canvas.height;
  const projection = mat4Perspective(Math.PI / 3, aspect, 0.1, 260.0);
  const view = computeCamera();

  gl.useProgram(program);
  gl.uniformMatrix4fv(uniforms.projection, false, new Float32Array(projection));
  gl.uniformMatrix4fv(uniforms.view, false, new Float32Array(view));

  gl.uniform3fv(uniforms.lightDir, new Float32Array(vec3Normalize([0.3, 1.0, 0.5])));
  gl.uniform3fv(uniforms.ambient,  new Float32Array([0.08, 0.08, 0.12]));
  gl.uniform3fv(uniforms.fogColor, new Float32Array([0.02, 0.03, 0.06]));
  gl.uniform1f(uniforms.fogNear, 12.0);
  gl.uniform1f(uniforms.fogFar,  180.0);

  // Ground
  let model = mat4Identity();
  model = mat4Translate(model, [0, -1, 0]);
  model = mat4Scale(model, [220, 1, 220]);
  drawMesh(cubeMeshGround, model);

  // Buildings
  for (let i = 0; i < buildings.length; i++) {
    const b = buildings[i];
    let m = mat4Identity();
    m = mat4Translate(m, [b.x, b.h * 0.5, b.z]);
    m = mat4Scale(m, [3.2, b.h * 0.5, 3.2]);
    drawMesh(cubeMeshBuilding, m);
  }

  // Car
  let carModel = mat4Identity();
  carModel = mat4Translate(carModel, [car.x, car.y, car.z]);
  carModel = mat4RotateY(carModel, car.rotY);
  carModel = mat4Scale(carModel, [1.7, 0.7, 3.4]);
  drawMesh(cubeMeshCar, carModel);

  // Player (only when not in car)
  if (!inCar) {
    let pModel = mat4Identity();
    pModel = mat4Translate(pModel, [player.x, player.y, player.z]);
    pModel = mat4RotateY(pModel, player.rotY);
    pModel = mat4Scale(pModel, [0.6, 1.8, 0.6]);
    drawMesh(cubeMeshPlayer, pModel);
  }
}

render();
</script>
</body>
</html>
