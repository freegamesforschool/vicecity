<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Vice-City-Style WebGL Demo (No Three.js)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #05070b;
      font-family: Arial, sans-serif;
      color: #eee;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.5);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 13px;
    }
    #ui h1 {
      margin: 0 0 6px 0;
      font-size: 16px;
      color: #ff66aa;
    }
    #ui p {
      margin: 2px 0;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<div id="ui">
  <h1>Vice City-ish WebGL</h1>
  <p><b>Move on foot:</b> WASD</p>
  <p><b>Turn:</b> Q/E</p>
  <p><b>Enter / Exit car:</b> F (near car)</p>
  <p><b>Camera:</b> Locked behind player or car</p>
</div>
<canvas id="glcanvas"></canvas>

<script>
// =========================================================
// Basic setup
// =========================================================
const canvas = document.getElementById("glcanvas");
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

const gl = canvas.getContext("webgl");
if (!gl) {
  alert("WebGL not supported");
}

// =========================================================
// Simple shader sources
// =========================================================
const vsSource = `
attribute vec3 aPosition;
attribute vec3 aNormal;
attribute vec3 aColor;

uniform mat4 uProjection;
uniform mat4 uView;
uniform mat4 uModel;

varying vec3 vColor;
varying vec3 vNormal;
varying vec3 vWorldPos;

void main(void) {
  vec4 worldPos = uModel * vec4(aPosition, 1.0);
  vWorldPos = worldPos.xyz;
  vNormal = mat3(uModel) * aNormal;
  vColor = aColor;
  gl_Position = uProjection * uView * worldPos;
}
`;

const fsSource = `
precision mediump float;

varying vec3 vColor;
varying vec3 vNormal;
varying vec3 vWorldPos;

uniform vec3 uLightDir;
uniform vec3 uAmbientColor;
uniform vec3 uFogColor;
uniform float uFogNear;
uniform float uFogFar;

void main(void) {
  vec3 n = normalize(vNormal);
  float diff = max(dot(-uLightDir, n), 0.0);
  vec3 base = vColor * (0.2 + diff * 0.8);

  float dist = length(vWorldPos);
  float fogFactor = clamp((uFogFar - dist) / (uFogFar - uFogNear), 0.0, 1.0);
  vec3 color = mix(uFogColor, base, fogFactor);

  gl_FragColor = vec4(color, 1.0);
}
`;

// =========================================================
// Shader compilation helpers
// =========================================================
function compileShader(src, type) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

function createProgram(vsSrc, fsSrc) {
  const vs = compileShader(vsSrc, gl.VERTEX_SHADER);
  const fs = compileShader(fsSrc, gl.FRAGMENT_SHADER);
  const prog = gl.createProgram();
  gl.attachShader(prog, vs);
  gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(prog));
    return null;
  }
  return prog;
}

const program = createProgram(vsSource, fsSource);
gl.useProgram(program);

// =========================================================
// Attribute / uniform locations
// =========================================================
const attribs = {
  position: gl.getAttribLocation(program, "aPosition"),
  normal:   gl.getAttribLocation(program, "aNormal"),
  color:    gl.getAttribLocation(program, "aColor")
};

const uniforms = {
  projection: gl.getUniformLocation(program, "uProjection"),
  view:       gl.getUniformLocation(program, "uView"),
  model:      gl.getUniformLocation(program, "uModel"),
  lightDir:   gl.getUniformLocation(program, "uLightDir"),
  ambient:    gl.getUniformLocation(program, "uAmbientColor"),
  fogColor:   gl.getUniformLocation(program, "uFogColor"),
  fogNear:    gl.getUniformLocation(program, "uFogNear"),
  fogFar:     gl.getUniformLocation(program, "uFogFar")
};

// =========================================================
// Minimal mat4 / vec3 utilities
// =========================================================
function mat4Identity() {
  return [1,0,0,0,
          0,1,0,0,
          0,0,1,0,
          0,0,0,1];
}

function mat4Multiply(a, b) {
  const out = new Array(16);
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      out[i*4 + j] =
        a[i*4 + 0] * b[0*4 + j] +
        a[i*4 + 1] * b[1*4 + j] +
        a[i*4 + 2] * b[2*4 + j] +
        a[i*4 + 3] * b[3*4 + j];
    }
  }
  return out;
}

function mat4Translate(m, v) {
  const [x,y,z] = v;
  const t = mat4Identity();
  t[12] = x;
  t[13] = y;
  t[14] = z;
  return mat4Multiply(m, t);
}

function mat4Scale(m, v) {
  const [x,y,z] = v;
  const s = mat4Identity();
  s[0] = x;
  s[5] = y;
  s[10] = z;
  return mat4Multiply(m, s);
}

function mat4RotateY(m, rad) {
  const c = Math.cos(rad);
  const s = Math.sin(rad);
  const r = [
    c, 0, -s, 0,
    0, 1,  0, 0,
    s, 0,  c, 0,
    0, 0,  0, 1
  ];
  return mat4Multiply(m, r);
}

function mat4Perspective(fov, aspect, near, far) {
  const f = 1.0 / Math.tan(fov / 2);
  const nf = 1 / (near - far);
  const out = new Array(16);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;

  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;

  out[8] = 0;
  out[9] = 0;
  out[10] = (far + near) * nf;
  out[11] = -1;

  out[12] = 0;
  out[13] = 0;
  out[14] = (2 * far * near) * nf;
  out[15] = 0;
  return out;
}

function vec3Normalize(v) {
  const len = Math.hypot(v[0], v[1], v[2]);
  if (len === 0) return [0,0,0];
  return [v[0]/len, v[1]/len, v[2]/len];
}

function mat4LookAt(eye, center, up) {
  const [ex,ey,ez] = eye;
  const [cx,cy,cz] = center;
  const [ux,uy,uz] = up;

  let zx = ex - cx;
  let zy = ey - cy;
  let zz = ez - cz;
  let zlen = Math.hypot(zx, zy, zz);
  if (zlen === 0) {
    zx = 0; zy = 0; zz = 1; zlen = 1;
  }
  zx /= zlen; zy /= zlen; zz /= zlen;

  let xx = uy * zz - uz * zy;
  let xy = uz * zx - ux * zz;
  let xz = ux * zy - uy * zx;
  let xlen = Math.hypot(xx, xy, xz);
  if (xlen === 0) {
    xx = 1; xy = 0; xz = 0; xlen = 1;
  }
  xx /= xlen; xy /= xlen; xz /= xlen;

  let yx = zy * xz - zz * xy;
  let yy = zz * xx - zx * xz;
  let yz = zx * xy - zy * xx;

  const out = mat4Identity();
  out[0] = xx; out[1] = yx; out[2] = zx; out[3] = 0;
  out[4] = xy; out[5] = yy; out[6] = zy; out[7] = 0;
  out[8] = xz; out[9] = yz; out[10] = zz; out[11] = 0;
  out[12] = -(xx*ex + xy*ey + xz*ez);
  out[13] = -(yx*ex + yy*ey + yz*ez);
  out[14] = -(zx*ex + zy*ey + zz*ez);
  out[15] = 1;
  return out;
}

// =========================================================
// Geometry: simple cube
// =========================================================
function createCubeGeometry(color) {
  const c = color || [1,1,1];

  const positions = [
    // Front
    -1,-1, 1,
     1,-1, 1,
     1, 1, 1,
    -1, 1, 1,
    // Back
    -1,-1,-1,
    -1, 1,-1,
     1, 1,-1,
     1,-1,-1,
    // Top
    -1, 1,-1,
    -1, 1, 1,
     1, 1, 1,
     1, 1,-1,
    // Bottom
    -1,-1,-1,
     1,-1,-1,
     1,-1, 1,
    -1,-1, 1,
    // Right
     1,-1,-1,
     1, 1,-1,
     1, 1, 1,
     1,-1, 1,
    // Left
    -1,-1,-1,
    -1,-1, 1,
    -1, 1, 1,
    -1, 1,-1
  ];

  const normals = [
    // Front
    0,0,1, 0,0,1, 0,0,1, 0,0,1,
    // Back
    0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1,
    // Top
    0,1,0, 0,1,0, 0,1,0, 0,1,0,
    // Bottom
    0,-1,0, 0,-1,0, 0,-1,0, 0,-1,0,
    // Right
    1,0,0, 1,0,0, 1,0,0, 1,0,0,
    // Left
    -1,0,0, -1,0,0, -1,0,0, -1,0,0
  ];

  const colors = [];
  for (let i = 0; i < 24; i++) {
    colors.push(c[0], c[1], c[2]);
  }

  const indices = [
    0,1,2, 0,2,3,
    4,5,6, 4,6,7,
    8,9,10, 8,10,11,
    12,13,14, 12,14,15,
    16,17,18, 16,18,19,
    20,21,22, 20,22,23
  ];

  return { positions, normals, colors, indices };
}

// =========================================================
// Create buffers
// =========================================================
function createMesh(geom) {
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);

  const posBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geom.positions), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(attribs.position);
  gl.vertexAttribPointer(attribs.position, 3, gl.FLOAT, false, 0, 0);

  const norBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, norBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geom.normals), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(attribs.normal);
  gl.vertexAttribPointer(attribs.normal, 3, gl.FLOAT, false, 0, 0);

  const colBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, colBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geom.colors), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(attribs.color);
  gl.vertexAttribPointer(attribs.color, 3, gl.FLOAT, false, 0, 0);

  const idxBuf = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(geom.indices), gl.STATIC_DRAW);

  gl.bindVertexArray(null);

  return {
    vao,
    count: geom.indices.length
  };
}

// =========================================================
// Scene objects
// =========================================================
const groundColor = [0.05, 0.12, 0.18];
const buildingColor = [0.15, 0.4, 0.7];
const carColor = [0.9, 0.1, 0.2];
const playerColor = [0.9, 0.9, 0.2];

const cubeMeshGround = createMesh(createCubeGeometry(groundColor));
const cubeMeshBuilding = createMesh(createCubeGeometry(buildingColor));
const cubeMeshCar = createMesh(createCubeGeometry(carColor));
const cubeMeshPlayer = createMesh(createCubeGeometry(playerColor));

// Generate a simple "city" grid of buildings
const buildings = [];
for (let x = -5; x <= 5; x++) {
  for (let z = -5; z <= 5; z++) {
    if (Math.abs(x) < 2 && Math.abs(z) < 2) continue;
    if (Math.random() < 0.4) {
      buildings.push({
        x: x * 8,
        z: z * 8,
        h: 4 + Math.random() * 20
      });
    }
  }
}

// Player and car state
const player = {
  x: 0,
  y: 1,
  z: 0,
  rotY: 0,
  speed: 0,
  maxSpeed: 0.15,
  accel: 0.01,
  friction: 0.9
};

const car = {
  x: 10,
  y: 1,
  z: -10,
  rotY: Math.PI * 0.25,
  speed: 0,
  maxSpeed: 0.4,
  accel: 0.02,
  friction: 0.92
};

let inCar = false;

// =========================================================
// Input handling
// =========================================================
const keys = {};
window.addEventListener("keydown", (e) => {
  keys[e.key.toLowerCase()] = true;
});
window.addEventListener("keyup", (e) => {
  keys[e.key.toLowerCase()] = false;
});

// =========================================================
// Camera logic: locked behind player or car
// =========================================================
function getControlledEntity() {
  return inCar ? car : player;
}

function updateMovement() {
  const ent = getControlledEntity();

  // Rotation with Q/E
  if (keys["q"]) {
    ent.rotY += 0.05;
  }
  if (keys["e"]) {
    ent.rotY -= 0.05;
  }

  // Forward/back with W/S
  let forward = 0;
  if (keys["w"]) forward += 1;
  if (keys["s"]) forward -= 1;

  if (forward !== 0) {
    ent.speed += forward * ent.accel;
    if (ent.speed > ent.maxSpeed) ent.speed = ent.maxSpeed;
    if (ent.speed < -ent.maxSpeed * 0.5) ent.speed = -ent.maxSpeed * 0.5;
  } else {
    ent.speed *= ent.friction;
  }

  const dx = Math.sin(ent.rotY) * ent.speed;
  const dz = Math.cos(ent.rotY) * ent.speed;

  ent.x += dx;
  ent.z += dz;

  // Simple "stay above ground"
  ent.y = 1;

  // Enter / exit car with F
  if (keys["f"]) {
    // Debounce-ish: only toggle when key first pressed
    if (!updateMovement._fPressed) {
      updateMovement._fPressed = true;
      if (!inCar) {
        // Check distance to car
        const dist = Math.hypot(player.x - car.x, player.z - car.z);
        if (dist < 4) {
          inCar = true;
          // Snap player to car
          player.x = car.x;
          player.z = car.z;
          player.rotY = car.rotY;
        }
      } else {
        // Exit car: place player slightly behind car
        inCar = false;
        player.x = car.x - Math.sin(car.rotY) * 3;
        player.z = car.z - Math.cos(car.rotY) * 3;
        player.rotY = car.rotY;
      }
    }
  } else {
    updateMovement._fPressed = false;
  }
}

function computeCamera() {
  const ent = getControlledEntity();

  // Camera offset behind entity
  const camDistance = inCar ? 12 : 8;
  const camHeight = inCar ? 4 : 3;

  const behindX = ent.x - Math.sin(ent.rotY) * camDistance;
  const behindZ = ent.z - Math.cos(ent.rotY) * camDistance;
  const eye = [behindX, ent.y + camHeight, behindZ];
  const center = [ent.x, ent.y + 1.5, ent.z];
  const up = [0,1,0];

  return mat4LookAt(eye, center, up);
}

// =========================================================
// Drawing helpers
// =========================================================
function drawMesh(mesh, modelMatrix) {
  gl.uniformMatrix4fv(uniforms.model, false, new Float32Array(modelMatrix));
  gl.bindVertexArray(mesh.vao);
  gl.drawElements(gl.TRIANGLES, mesh.count, gl.UNSIGNED_SHORT, 0);
}

// =========================================================
// Main loop
// =========================================================
function render() {
  requestAnimationFrame(render);

  updateMovement();

  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.enable(gl.DEPTH_TEST);
  gl.clearColor(0.02, 0.03, 0.06, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  const aspect = canvas.width / canvas.height;
  const projection = mat4Perspective(Math.PI / 3, aspect, 0.1, 200.0);
  const view = computeCamera();

  gl.useProgram(program);
  gl.uniformMatrix4fv(uniforms.projection, false, new Float32Array(projection));
  gl.uniformMatrix4fv(uniforms.view, false, new Float32Array(view));

  gl.uniform3fv(uniforms.lightDir, new Float32Array(vec3Normalize([0.3, 1.0, 0.5])));
  gl.uniform3fv(uniforms.ambient, new Float32Array([0.1, 0.1, 0.15]));
  gl.uniform3fv(uniforms.fogColor, new Float32Array([0.02, 0.03, 0.06]));
  gl.uniform1f(uniforms.fogNear, 10.0);
  gl.uniform1f(uniforms.fogFar, 120.0);

  // Draw ground as a huge flat cube
  let model = mat4Identity();
  model = mat4Translate(model, [0, -1, 0]);
  model = mat4Scale(model, [200, 1, 200]);
  drawMesh(cubeMeshGround, model);

  // Draw buildings
  for (let i = 0; i < buildings.length; i++) {
    const b = buildings[i];
    let m = mat4Identity();
    m = mat4Translate(m, [b.x, b.h * 0.5, b.z]);
    m = mat4Scale(m, [3, b.h * 0.5, 3]);
    drawMesh(cubeMeshBuilding, m);
  }

  // Draw car
  let carModel = mat4Identity();
  carModel = mat4Translate(carModel, [car.x, car.y, car.z]);
  carModel = mat4RotateY(carModel, car.rotY);
  carModel = mat4Scale(carModel, [1.5, 0.7, 3]);
  drawMesh(cubeMeshCar, carModel);

  // Draw player (only when not in car, for clarity)
  if (!inCar) {
    let pModel = mat4Identity();
    pModel = mat4Translate(pModel, [player.x, player.y, player.z]);
    pModel = mat4RotateY(pModel, player.rotY);
    pModel = mat4Scale(pModel, [0.6, 1.8, 0.6]);
    drawMesh(cubeMeshPlayer, pModel);
  }
}

render();
</script>
</body>
</html>
